<!doctype html>
<html>
<head>
<meta charset="utf-8">
<title>FP Tester</title>
<style>body{font-family:system-ui,Segoe UI,Roboto,Arial;margin:18px;color:#111} pre{background:#f6f6f6;padding:12px;border-radius:6px;overflow:auto}</style>
</head>
<body>
<h2>Fingerprint & API availability tester</h2>
<p>Open Console (F12) and scroll this page. Compare outputs across browsers/profiles.</p>
<pre id="out">Collectingâ€¦</pre>
<script>
(async function(){
  const O = (k,v)=>document.getElementById('out').textContent += `\n${k}: ${v}`;
  document.getElementById('out').textContent = '';
  O('Time', new Date().toISOString());
  O('UserAgent', navigator.userAgent || 'n/a');
  O('Platform', navigator.platform || 'n/a');
  O('Language', navigator.language || 'n/a');
  O('Screen', `${screen.width}x${screen.height} DPR=${window.devicePixelRatio}`);
  O('Cores', navigator.hardwareConcurrency || 'n/a');
  O('DeviceMemory', navigator.deviceMemory || 'n/a');

  // Canvas
  try{
    const c = document.createElement('canvas'); c.width=200;c.height=60;
    const ctx = c.getContext('2d');
    ctx.fillStyle='#f60'; ctx.fillRect(0,0,200,60);
    ctx.font='20px Arial'; ctx.fillStyle='#069';
    ctx.fillText('fp-test-'+Math.random().toString(36).slice(2,6),10,35);
    const data = c.toDataURL();
    O('Canvas dataURL len', (data||'').length);
    // sample bytes
    O('Canvas sample slice', (data||'').slice(0,80));
  }catch(e){O('Canvas error', e.message||e);}

  // WebGL (params)
  try{
    const cgl = document.createElement('canvas');
    const gl = cgl.getContext('webgl') || cgl.getContext('experimental-webgl');
    if(!gl) { O('WebGL', 'not available'); }
    else {
      const dbg = gl.getExtension('WEBGL_debug_renderer_info');
      O('WebGL maxTextureSize', gl.getParameter(gl.MAX_TEXTURE_SIZE));
      if(dbg) {
        O('WebGL UNMASKED_VENDOR', gl.getParameter(dbg.UNMASKED_VENDOR_WEBGL));
        O('WebGL UNMASKED_RENDERER', gl.getParameter(dbg.UNMASKED_RENDERER_WEBGL));
      } else O('WebGL debug ext', 'not available');
    }
  }catch(e){O('WebGL error', e.message||e);}

  // Audio fingerprint attempt
  try{
    const OfflineCtx = window.OfflineAudioContext || window.webkitOfflineAudioContext;
    if(!OfflineCtx){ O('AudioFP', 'OfflineAudioContext not supported'); }
    else{
      const ctx = new OfflineCtx(1,44100,44100);
      const o = ctx.createOscillator();
      const c = ctx.createDynamicsCompressor();
      o.type='triangle'; o.frequency.setValueAtTime(10000,0);
      o.connect(c); c.connect(ctx.destination);
      o.start(0); o.stop(ctx.currentTime + 0.1);
      const rendered = await ctx.startRendering();
      const channel = rendered.getChannelData(0);
      let s=0; for(let i=4500;i<5000 && i<channel.length;i++) s+=Math.abs(channel[i]);
      O('Audio fingerprint value', s.toFixed(8));
    }
  }catch(e){O('Audio error', e.message||e);}

  // Keyboard layout
  try{
    if(navigator.keyboard && navigator.keyboard.getLayoutMap){
      const map = await navigator.keyboard.getLayoutMap();
      O('KeyQ sample', map.get('KeyQ'));
    } else O('Keyboard API', 'not supported');
  }catch(e){O('Keyboard error', e.message||e);}

  // MediaDevices
  try{
    if(navigator.mediaDevices && navigator.mediaDevices.enumerateDevices){
      const dev = await navigator.mediaDevices.enumerateDevices();
      O('MediaDevices count', dev.length);
    } else O('MediaDevices', 'not available');
  }catch(e){O('MediaDevices error', e.message||e);}

  // WebRTC local IPs
  async function getIPs(){
    try{
      const ips=[];
      const pc = new RTCPeerConnection({iceServers:[]});
      pc.createDataChannel('');
      const offer = await pc.createOffer();
      await pc.setLocalDescription(offer);
      await new Promise(resolve=>{
        const t=setTimeout(resolve,1500);
        pc.onicecandidate = (ev)=>{ if(!ev || !ev.candidate){ clearTimeout(t); resolve(); return; }
          const m=/([0-9]{1,3}\.){3}[0-9]{1,3}/.exec(ev.candidate.candidate);
          if(m && !ips.includes(m[0])) ips.push(m[0]);
        };
      });
      pc.close();
      return ips;
    }catch(e){ return ['webrtc error:'+ (e.message||e)];}
  }
  O('WebRTC local IPs (may be blocked)', (await getIPs()).join(', ') );

  // Storage keys
  try{ O('localStorage keys', Object.keys(localStorage||{}).slice(0,20).join(', ') || '(none)'); }catch(e){ O('localStorage error', e.message||e); }
  try{ O('Cookies', document.cookie || '(none)'); }catch(e){ O('Cookies error', e.message||e); }

  // End
  O('--- DONE ---','');
})();
</script>
</body>
</html>
